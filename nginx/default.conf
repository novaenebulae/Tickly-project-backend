# Définition d'un groupe de serveurs backend (upstream).
# Ce bloc est particulièrement utile pour la répartition de charge (load balancing)
# si vous prévoyez de déployer plusieurs instances de votre application Java.
upstream java_app_backend {
    # 'app_java' est le nom du service de l'application Java tel que défini dans docker-compose.yml.
    # Nginx, s'exécutant dans le même réseau Docker que l'application Java,
    # utilisera la résolution DNS interne de Docker pour trouver l'adresse IP du conteneur 'app_java'.
    # '8080' est le port sur lequel l'application Java écoute A L'INTERIEUR de son conteneur.
    server app_java:8080;
    # Commentaire: Le nom 'app_java' doit correspondre exactement au nom du service
    # de l'application Java dans le fichier docker-compose.yml.
    # Le port 8080 est le port interne de l'application Java (défini par server.port).
}

server {
    # Nginx écoute sur le port 80 (HTTP standard) pour les requêtes entrantes.
    listen 80;
    # Commentaire: C'est le port exposé par Nginx au monde extérieur (ou à l'hôte Docker).

    # Nom du serveur. Pour le développement local, 'localhost' est suffisant.
    # En production, ce serait votre nom de domaine (e.g., www.example.com).
    server_name localhost;
    # Commentaire: Permet à Nginx de gérer les requêtes pour ce nom d'hôte spécifique.

    charset utf-8;

    # Configuration pour la racine du serveur (/).
    # Toutes les requêtes arrivant sur ce serveur et ce port seront traitées par ce bloc 'location',
    # à moins qu'une 'location' plus spécifique ne corresponde.
    location / {
        # 'proxy_pass' est la directive clé qui transfère la requête au groupe de serveurs
        # backend défini dans le bloc 'upstream' nommé 'java_app_backend'.
        proxy_pass http://java_app_backend;
        # Commentaire: La requête est transmise au service 'app_java' sur le port 8080.

        # Paramètres d'en-tête importants pour un reverse proxy.
        # Ces en-têtes aident l'application backend à connaître les détails de la requête client originale,
        # qui pourraient être masqués ou modifiés par le proxy.
        proxy_set_header Host $host; # Transmet l'en-tête 'Host' original de la requête client.
        proxy_set_header X-Real-IP $remote_addr; # Transmet l'adresse IP réelle du client.
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # Ajoute l'IP du proxy à la liste des IP traversées.
        proxy_set_header X-Forwarded-Proto $scheme; # Transmet le protocole original utilisé par le client (http ou https).
        # Commentaire: Ces en-têtes sont cruciaux pour que l'application backend fonctionne correctement
        # (par exemple, pour la génération d'URL absolues, les logs, les restrictions basées sur l'IP).

        # Augmenter les timeouts si nécessaire pour les requêtes longues (optionnel).
        # proxy_connect_timeout 60s; # Temps d'attente pour établir une connexion avec le backend.
        # proxy_send_timeout 60s;    # Temps d'attente pour envoyer une requête au backend.
        # proxy_read_timeout 60s;    # Temps d'attente pour recevoir une réponse du backend.
    }

    # Augmenter la taille maximale du corps de la requête pour les uploads (notamment les avatars)
    client_max_body_size 20M;

    # Configuration correcte du proxy vers le service Java
    location /api {
        # Utiliser le nom du upstream défini au début du fichier
        proxy_pass http://java_app_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Augmenter les timeouts pour les requêtes de chargement de fichiers
        proxy_connect_timeout 300s;
        proxy_send_timeout 300s;
        proxy_read_timeout 300s;

        # Configurer correctement le buffering pour les grands fichiers
        proxy_request_buffering off;
        proxy_buffering off;
           }

           # Configuration pour servir les fichiers statiques
           location /static {
        alias /var/www/html/static;
        access_log off;
        expires max;
           }


    # Optionnel : Servir une application frontend statique (ex: Angular)
        # location / {
        #     root /usr/share/nginx/html/frontend; # Chemin vers les fichiers de votre frontend buildé
        #     try_files $uri $uri/ /index.html;
        # }

    # Pages d'erreur personnalisées (optionnel).
    # Nginx peut servir des pages d'erreur personnalisées au lieu de celles par défaut.
    error_page 500 502 503 504 /50x.html;
    location = /50x.html {
        # Chemin vers les pages d'erreur Nginx par défaut (ou vos pages personnalisées).
        root /usr/share/nginx/html;
    }
}